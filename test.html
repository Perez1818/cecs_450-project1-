<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>D3 Map Example</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div style="margin: 10px">
      <label for="dataChoice">Show data by: </label>
      <select id="dataChoice">
        <option value="race and Age">Race and Age</option>
        <option value="bar">Income and Region</option>
      </select>
    </div>
    <div id="chart"></div>
    <script src="/library/d3.v7.min.js"></script>
    <script src="/library/topojson.js"></script>
    <script src="/piechart.js"></script>
    <script src="/bargraph.js"></script>
    <script type="module">
      let choice = "race and Age"; // default
      //References:
      //- Use Zoom to bounding box: https://observablehq.com/@d3/zoom-to-bounding-box
      //- Pie chart: https://observablehq.com/@d3/pie-chart
      //- features geometries of all states https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json
      //- topology: topojson.js: https://unpkg.com/topojson@3
      //- html: how to use d3 code: https://d3js.org/getting-started
      //- Combine Zoomed map with pie chart: ChatGPT
      //- Bargraph with tooltips: https://observablehq.com/@d3/bar-chart/2
      //- Change Color Map: ChatGPT
      //- Tool: Visual Studio Code
      //- Data source: Obesity data from CDC 2019: https://www.cdc.gov/obesity/data/prevalence-maps.html

      //go live with ip: http://localhost:8080/main.html
      //using python command to run on port 8080: python3 -m http.server 8080
      //Pan and zoom, or click to zoom into a particular state using zoom.transform transitions.The bounding box is computed using path.bounds.
      import { stateAndObe } from "./zoombounding.js";
      function clearChart() {
        const chartDiv = document.getElementById("chart");
        while (chartDiv.firstChild) {
          chartDiv.removeChild(chartDiv.firstChild);
        }
      }
      async function updateChart() {
        d3.selectAll(".popup").remove(); // Consistent popup cleanup
        clearChart();
        if (choice === "race and Age") {
          function Chart(us) {
            const width = window.innerWidth * 0.5;
            const height = window.innerHeight;

            const zoom = d3
              .zoom()
              .scaleExtent([1, 100]) //limit zoom scale
              .on("zoom", zoomed);

            const svg = d3
              .create("svg")
              .attr("viewBox", [0, 0, width, height])
              .attr("width", width)
              .attr("height", height)
              .attr("style", "max-width: 100%; height: auto;")
              .on("click", reset);

            const path = d3.geoPath();

            const g = svg.append("g");
            const populationData = stateAndObe; //import from zoombounding.js. Color scale based on obesity data

            //change color scale based on population data ***testing purpose only: ChatGPT***
            const minValue = d3.min(Object.values(populationData));
            const maxValue = d3.max(Object.values(populationData));
            const colorScale = d3
              .scaleLinear()
              .domain([minValue, maxValue])
              .range(["#FFFFFf", "#800026"]);
            console.log(populationData);
            const states = g
              .append("g")
              .attr("fill", "#0000") //default color white
              .attr("cursor", "pointer")
              .selectAll("path")
              .data(topojson.feature(us, us.objects.states).features)
              .join("path")
              .attr("fill", (d) =>
                colorScale(populationData[d.properties.name] || 0)
              ) //change color scale based on population data ***testing purpose only***
              .on("click", clicked)
              .attr("d", path);

            // Define tooltip functions to avoid event accumulation
            function showMapTooltip(event, d) {
              const obesityRate = populationData[d.properties.name] || 0;
              const tooltip = d3
                .select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("background", "lightgray")
                .style("padding", "5px")
                .style("border-radius", "5px")
                .style("pointer-events", "none")
                .html(
                  `<strong>${d.properties.name}</strong><br/>Obesity Rate: ${obesityRate}%`
                );
              return tooltip;
            }

            function moveMapTooltip(event) {
              d3.select(".tooltip")
                .style("left", event.pageX + 10 + "px")
                .style("top", event.pageY + 10 + "px");
            }

            function hideMapTooltip() {
              d3.select(".tooltip").remove();
            }

            // Add tooltip on hover to show state name and obesity rate
            states
              .attr("fill", (d) =>
                colorScale(populationData[d.properties.name] || 0)
              )
              .on("click", clicked)
              .on("mouseover", showMapTooltip)
              .on("mousemove", moveMapTooltip)
              .on("mouseout", hideMapTooltip);

            g.append("path")
              .attr("fill", "none")
              .attr("stroke", "white")
              .attr("stroke-linejoin", "round")
              .attr(
                "d",
                path(topojson.mesh(us, us.objects.states, (a, b) => a !== b))
              );
            svg.call(zoom);
            /**** Adding simple legend for 0%, 50%, 100% ****/
            const legend = svg
              .append("g")
              .attr("transform", `translate(${width / 3}, 20)`); // Center at top

            const legendPoints = [
              {
                value: minValue,
                color: colorScale(minValue),
                label: `${Math.round(minValue)}%`,
              },
              {
                value: (minValue + maxValue) / 2,
                color: colorScale((minValue + maxValue) / 2),
                label: `${Math.round((minValue + maxValue) / 2)}%`,
              },
              {
                value: maxValue,
                color: colorScale(maxValue),
                label: `${Math.round(maxValue)}%`,
              },
            ];

            // Draw legend squares and labels
            legendPoints.forEach((point, i) => {
              // Draw square
              legend
                .append("rect")
                .attr("x", i * 50) // Space squares 50px apart
                .attr("y", 0)
                .attr("width", 30)
                .attr("height", 30)
                .style("fill", point.color);

              // Draw label
              legend
                .append("text")
                .attr("x", i * 50 + 10)
                .attr("y", 35)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text(point.label);
            });

            // Add legend title
            legend
              .append("text")
              .attr("x", 75) // Center of 3 squares (3 * 50 / 2)
              .attr("y", -5)
              .attr("text-anchor", "middle")
              .style("font-size", "14px")
              .text("Obesity Rate (%)");

            function reset() {
              //states.transition().style("fill", null);
              states
                .transition()
                .style("fill", (d) =>
                  colorScale(populationData[d.properties.name] || 0)
                );
              svg
                .transition()
                .duration(750)
                .call(
                  zoom.transform,
                  d3.zoomIdentity,
                  d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
                );
              d3.selectAll(".popup").remove();
            }

            async function clicked(event, d) {
              d3.selectAll(".popup").remove();
              const [[x0, y0], [x1, y1]] = path.bounds(d);
              event.stopPropagation();
              states
                .transition()
                .style("fill", (d) =>
                  colorScale(populationData[d.properties.name] || 0)
                );
              // Highlight selected state by changing another states color to Gray
              //d3.select(this).transition().style("fill", "white");
              states
                .filter((state) => state !== d)
                .transition()
                .style("fill", "#444");

              // zoom to bounding box
              svg
                .transition()
                .duration(750)
                .call(
                  zoom.transform,
                  d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(
                      Math.min(
                        5,
                        0.5 / Math.max((x1 - x0) / width, (y1 - y0) / height)
                      )
                    )
                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2), //change 1.78 to 2 to adjust position of zoomed state
                  d3.zoomTransform(svg.node()).invert([width / 2, height / 2]) // Center the state
                );

              /**** Start Draw Pie Chart when click on a state ****/
              const stateName = d.properties.name;
              let data = {};
              let data2 = {};
              if (choice === "race and Age") {
                data = await getRaceData(stateName);
                data2 = await getAgeData(stateName);

                if (!data || !data.length) {
                  console.error("Check data in piechart.js");
                  return;
                }

                /**** Set up pie chart dimensions ****/
                const pieWidth = window.innerWidth * 0.5;
                const pieHeight = window.innerHeight;
                const radius = Math.min(pieWidth, pieHeight) / 2 - 20; // radius of the pie chart

                // Create the color for piechart.
                const color = d3
                  .scaleOrdinal()
                  .domain(data.map((d) => d.name))
                  .range(["#808080", "#F5F5DC", "#8B4513"]); // Gray, Beige, Brown

                // Create the pie layout and arc generator.
                const pie = d3
                  .pie()
                  .sort(null)
                  .value((d) => d.value);

                const arc = d3
                  .arc()
                  .innerRadius(0)
                  .outerRadius(Math.min(pieWidth, pieHeight) / 2 - 1);

                const labelRadius = arc.outerRadius()() * 0.8;

                // A separate arc generator for labels.
                const arcLabel = d3
                  .arc()
                  .innerRadius(labelRadius)
                  .outerRadius(labelRadius);

                const arcs = pie(data);

                // Create the SVG container.
                const pieSvg = d3
                  .create("svg")
                  .attr("width", pieWidth)
                  .attr("height", pieHeight)
                  .attr("viewBox", [
                    -pieWidth / 2,
                    -pieHeight / 2,
                    pieWidth,
                    pieHeight,
                  ])
                  .attr(
                    "style",
                    `max-width: 100%; height: 100%; font: ${
                      pieWidth * 0.03
                    }px sans-serif;`
                  );

                // Add a sector path for each value.
                pieSvg
                  .append("g")
                  .attr("stroke", "white")
                  .selectAll()
                  .data(arcs)
                  .join("path")
                  .attr("fill", (d) => color(d.data.name))
                  .attr("d", arc)
                  .append("title")
                  .text(
                    (d) =>
                      `${d.data.name}: ${d.data.value.toLocaleString("en-US")}`
                  );

                // Create a new arc generator to place a label close to the edge.
                pieSvg
                  .append("g")
                  .attr("text-anchor", "middle")
                  .selectAll()
                  .data(arcs)
                  .join("text")
                  .attr(
                    "transform",
                    (d) => `translate(${arcLabel.centroid(d)})`
                  )
                  .call((text) =>
                    text
                      .append("tspan")
                      .attr("y", "-0.4em")
                      .attr("font-weight", "bold")
                      .text((d) => d.data.name)
                  )
                  .call((text) =>
                    text
                      .filter((d) => d.endAngle - d.startAngle > 0.25)
                      .append("tspan")
                      .attr("x", 0)
                      .attr("y", "0.7em")
                      .attr("fill-opacity", 0.7)
                      .text((d) => d.data.value.toLocaleString("en-US"))
                  );

                // Create a popup div to hold the pie chart
                const popup1 = d3
                  .select("body")
                  .append("div")
                  .attr("class", "popup popup1 active");
                //PopUp title and close button
                popup1
                  .append("div")
                  .text(`Pie Chart (Race) for ${stateName}`)
                  .append("span")
                  .text("✖")
                  .on("click", () => popup1.remove());

                //Append pie chart to the popup
                popup1.append(() => pieSvg.node());

                //***--------------pop up 2 for age with heatmap---------------***//
                // Create a popup div to hold the pie chart and heatmap
                const popup2 = d3
                  .select("body")
                  .append("div")
                  .attr("class", "popup popup2 active");

                // PopUp title and close button
                popup2
                  .append("div")
                  .text(`Pie Chart (Age + Heatmap) for ${stateName}`)
                  .append("span")
                  .text("✖")
                  .on("click", () => popup2.remove());


                // --- Heatmap Section --- //
                const heatmapDiv = popup2
                  .append("div")
                  .attr("id", "heatmap-container")
                  .style("margin-top", "10px")
                  .style("padding", "10px");

                // Controls for heatmap
                const controlsDiv = heatmapDiv
                  .append("div")
                  .attr("id", "controls");
                const stateSelect = controlsDiv
                  .append("select")
                  .attr("id", "stateSelect");

                controlsDiv
                  .append("label")
                  .attr("for", "yearSlider")
                  .text("Year:");
                controlsDiv
                  .append("input")
                  .attr("type", "range")
                  .attr("id", "yearSlider")
                  .attr("min", 2013)
                  .attr("max", 2023)
                  .attr("step", 1)
                  .attr("value", 2023);
                controlsDiv.append("span").attr("id", "yearLabel").text("2023");
                controlsDiv.append("button").attr("id", "playBtn").text("Play");
                controlsDiv
                  .append("button")
                  .attr("id", "pauseBtn")
                  .text("Pause");

                const heatmapDivSVG = heatmapDiv
                  .append("div")
                  .attr("id", "heatmap");

                const margin = { top: 20, right: 50, bottom: 100, left: 120 },
                  width = 900 - margin.left - margin.right,
                  height = 400 - margin.top - margin.bottom;

                const svgHeatmap = d3
                  .select("#heatmap")
                  .append("svg")
                  .attr("width", width + margin.left + margin.right)
                  .attr("height", height + margin.top + margin.bottom)
                  .append("g")
                  .attr("transform", `translate(${margin.left},${margin.top})`);

                let dataGlobal;
                let playInterval;

                d3.csv("Behavioral_Risk_Factor_Surveillance_System.csv")
                  .then((data) => {
                    data.forEach((d) => {
                      d.Sample_Size = +d.Sample_Size.replace(/,/g, "");
                      d.Data_value = +d.Data_value;
                      d.Year = +d.Year;
                    });
                    dataGlobal = data;

                    const states = [
                      ...new Set(data.map((d) => d.Locationdesc)),
                    ];
                    states.forEach((s) =>
                      stateSelect.append("option").text(s).attr("value", s)
                    );

                    const ages = [
                      ...new Set(
                        data
                          .filter((d) => d.Topic === "Age")
                          .map((d) => d.Response)
                      ),
                    ];
                    const races = [
                      ...new Set(
                        data
                          .filter(
                            (d) => d.Break_Out_Category === "Race/Ethnicity"
                          )
                          .map((d) => d.Break_Out)
                      ),
                    ];

                    const xScale = d3
                      .scaleBand()
                      .domain(races)
                      .range([0, width])
                      .padding(0.05);
                    const yScale = d3
                      .scaleBand()
                      .domain(ages)
                      .range([0, height])
                      .padding(0.05);
                    const colorScale = d3
                      .scaleSequential()
                      .interpolator(d3.interpolateBlues);

                    // Axes
                    svgHeatmap
                      .append("g")
                      .attr("transform", `translate(0,${height})`)
                      .attr("class", "xAxis")
                      .call(d3.axisBottom(xScale))
                      .selectAll("text")
                      .attr("transform", "rotate(-45)")
                      .style("text-anchor", "end");
                    svgHeatmap
                      .append("g")
                      .attr("class", "yAxis")
                      .call(d3.axisLeft(yScale));

                    function updateHeatmap(state, year) {
                      const filtered = dataGlobal.filter(
                        (d) =>
                          d.Topic === "Age" &&
                          d.Break_Out_Category === "Race/Ethnicity" &&
                          d.Locationdesc === state &&
                          d.Year === +year
                      );

                      colorScale.domain([
                        0,
                        d3.max(filtered, (d) => d.Data_value),
                      ]);

                      const cells = svgHeatmap
                        .selectAll(".cell")
                        .data(filtered, (d) => d.Response + d.Break_Out);

                      cells
                        .enter()
                        .append("rect")
                        .attr("class", "cell")
                        .merge(cells)
                        .transition()
                        .duration(300)
                        .attr("x", (d) => xScale(d.Break_Out))
                        .attr("y", (d) => yScale(d.Response))
                        .attr("width", xScale.bandwidth())
                        .attr("height", yScale.bandwidth())
                        .attr("fill", (d) => colorScale(d.Data_value))
                        .selectAll("title")
                        .remove();

                      cells.select("title").remove();
                      cells
                        .append("title")
                        .text(
                          (d) =>
                            `Race: ${d.Break_Out}\nAge: ${d.Response}\nValue: ${d.Data_value}\nSample: ${d.Sample_Size}`
                        );

                      cells.exit().remove();
                    }

                    // Initial draw with the clicked state
                    const initialYear = +d3
                      .select("#yearSlider")
                      .property("value");
                    d3.select("#stateSelect").property("value", stateName); // Default to clicked state
                    updateHeatmap(stateName, initialYear);

                    // Event listeners
                    d3.select("#stateSelect").on("change", function () {
                      const state = this.value;
                      const year = +d3.select("#yearSlider").property("value");
                      updateHeatmap(state, year);
                    });

                    d3.select("#yearSlider").on("input", function () {
                      const year = +this.value;
                      d3.select("#yearLabel").text(year);
                      const state = d3.select("#stateSelect").property("value");
                      updateHeatmap(state, year);
                    });

                    d3.select("#playBtn").on("click", function () {
                      if (playInterval) clearInterval(playInterval);
                      let year = +d3.select("#yearSlider").property("value");
                      playInterval = setInterval(() => {
                        year++;
                        if (year > +d3.select("#yearSlider").attr("max"))
                          year = +d3.select("#yearSlider").attr("min");
                        d3.select("#yearSlider").property("value", year);
                        d3.select("#yearLabel").text(year);
                        const state = d3
                          .select("#stateSelect")
                          .property("value");
                        updateHeatmap(state, year);
                      }, 1000);
                    });

                    d3.select("#pauseBtn").on("click", function () {
                      if (playInterval) clearInterval(playInterval);
                    });
                  })
                  .catch((err) => console.error(err));
              }
            }

            function zoomed(event) {
              const { transform } = event;
              g.attr("transform", transform);
              g.attr("stroke-width", 1 / transform.k);
            }
            return svg.node();
          }

          //Use local topojson file states-albers-10m.json
          d3.json("states-albers-10m.json")
            .then((us) => {
              console.log("TopoJSON loaded:", us); //check if JSON data is loaded
              const chart = Chart(us);
              document.getElementById("chart").appendChild(chart);
            })
            .catch((err) => console.error("fail to load topojson:", err));
        }

        // bar graph
        else if (choice === "bar") {
          async function createBarChart() {
            let data = await getBarData();
            if (!data || !data.length) {
              console.error("Check data in bargraph.js");
              return;
            }

            // margin of the window (page)
            const margin = { top: 60, right: 300, bottom: 100, left: 300 };
            const width = window.innerWidth * 0.9 - margin.left - margin.right;
            const height =
              window.innerHeight * 0.6 - margin.top - margin.bottom;

            const svg = d3
              .create("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom);

            const g = svg
              .append("g")
              .attr("transform", `translate(${margin.left},${margin.top})`);

            // x-axis
            const x = d3
              .scaleBand()
              .domain(data.map((d) => d.region))
              .range([0, width])
              .padding(0.2);

            g.append("g")
              .attr("transform", `translate(0,${height})`)
              .call(d3.axisBottom(x));

            // y-axis left side is obesity %
            const yLeft = d3
              .scaleLinear()
              .domain([0, d3.max(data, (d) => d.obesity)])
              .nice()
              .range([height, 0]);

            g.append("g")
              .call(d3.axisLeft(yLeft))
              .append("text")
              .attr("x", -40)
              .attr("y", -10)
              .attr("fill", "black")
              .text("Obesity (%)");

            // y-axis right side is income $
            const yRight = d3
              .scaleLinear()
              .domain([0, d3.max(data, (d) => d.income)])
              .nice()
              .range([height, 0]);

            g.append("g")
              .attr("transform", `translate(${width},0)`)
              .call(d3.axisRight(yRight))
              .append("text")
              .attr("x", 40)
              .attr("y", -10)
              .attr("fill", "black")
              .text("Income ($)");

            // add title
            g.append("text")
              .attr("x", width / 2)
              .attr("y", -margin.top / 2) // Position above the g transform
              .attr("text-anchor", "middle")
              .style("font-size", "20px")
              .style("font-weight", "bold")
              .text("Obesity vs Income by Region");

            // create the bar as rectangle, in blue color
            const bars = g
              .selectAll("rect")
              .data(data)
              .join("rect")
              .attr("x", (d) => x(d.region))
              .attr("y", (d) => yLeft(d.obesity))
              .attr("width", x.bandwidth())
              .attr("height", (d) => height - yLeft(d.obesity))
              .attr("fill", "steelblue");

            // Add tooltip for blue bars (obesity)
            function showObesityTooltip(event, d) {
              const tooltip = d3
                .select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("background", "lightgray")
                .style("padding", "5px")
                .style("border-radius", "5px")
                .style("pointer-events", "none")
                .html(
                  `<strong>${d.region}</strong><br/>Average Obesity: ${d.obesity}%`
                );
              return tooltip;
            }

            // when the mouse moves in the hovering section
            function moveObesityTooltip(event) {
              d3.select(".tooltip")
                .style("left", event.pageX + 10 + "px")
                .style("top", event.pageY - 10 + "px");
            }

            // when the mouse moves out of the hovering section
            function hideObesityTooltip() {
              d3.select(".tooltip").remove();
            }

            bars
              .on("mouseover", showObesityTooltip)
              .on("mousemove", moveObesityTooltip)
              .on("mouseout", hideObesityTooltip);

            // add dots and lines for incomes
            const line = d3
              .line()
              .x((d) => x(d.region) + x.bandwidth() / 2)
              .y((d) => yRight(d.income));

            g.append("path")
              .datum(data)
              .attr("fill", "none")
              .attr("stroke", "orange")
              .attr("stroke-width", 2)
              .attr("d", line);

            const circles = g
              .selectAll("circle")
              .data(data)
              .join("circle")
              .attr("cx", (d) => x(d.region) + x.bandwidth() / 2)
              .attr("cy", (d) => yRight(d.income))
              .attr("r", 4)
              .attr("fill", "orange");

            // Add tooltip for orange dots (income)
            function showIncomeTooltip(event, d) {
              const tooltip = d3
                .select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("background", "lightgray")
                .style("padding", "5px")
                .style("border-radius", "5px")
                .style("pointer-events", "none")
                .html(
                  `<strong>${
                    d.region
                  }</strong><br/>Average Income: $${d.income.toLocaleString()}`
                );
              return tooltip;
            }

            // when the mouse moves in the hovering section
            function moveIncomeTooltip(event) {
              d3.select(".tooltip")
                .style("left", event.pageX + 10 + "px")
                .style("top", event.pageY - 10 + "px");
            }

            // when the mouse moves out of the hovering section
            function hideIncomeTooltip() {
              d3.select(".tooltip").remove();
            }

            circles
              .on("mouseover", showIncomeTooltip)
              .on("mousemove", moveIncomeTooltip)
              .on("mouseout", hideIncomeTooltip);

            // text elements for specifying states by regions
            const placeholderG = g
              .append("g")
              .attr("transform", `translate(0, ${height + 40})`); // Position below x-axis

            const lines = [
              "South States: Alabama, Georgia, Tennessee, Texas",
              "West States: Arizona, California, Nevada, New Mexico, Utah",
              "Midwest States: Illinois, Indiana, Missouri, Nebraska, Ohio",
              "Northeast States: New Jersey, New York, Massachusetts, Maine",
            ];

            // Append a separate text for each line
            placeholderG
              .selectAll("text")
              .data(lines)
              .join("text")
              .attr("x", width / 2) // Center each horizontally
              .attr("y", (d, i) => 10 + i * 15) // Stack vertically, starting 10px below, 15px apart
              .attr("text-anchor", "middle")
              .style("font-size", "12px")
              .style("fill", "black")
              .text((d) => d);

            return svg.node();
          }

          createBarChart().then((node) => {
            if (node) {
              document.getElementById("chart").appendChild(node);
            }
          });
        }
      }
      updateChart();
      document
        .getElementById("dataChoice")
        .addEventListener("change", function (e) {
          choice = e.target.value;
          updateChart();
        });
    </script>
  </body>
</html>
