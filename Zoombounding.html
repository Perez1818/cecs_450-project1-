<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>D3 Map Example</title>
</head>

<body>
    <div style="margin:10px;">
        <label for="dataChoice">Show data by: </label>
        <select id="dataChoice">
            <option value="race">Race</option>
            <option value="income">Income</option>
            <option value="age">Age</option>
        </select>
    </div>
    <div id="chart"></div>

    <div id="chart"></div>
    <script src="/library/d3.v7.min.js"></script>
    <script src="/library/topojson.js"></script>
    <script src="/piechart.js"></script>
    <script type="module">
        let choice = "race"; // default
        document.getElementById("dataChoice").addEventListener("change", function (e) {
            choice = e.target.value;
        });
        //References:
        //- Use Zoom to bounding box: https://observablehq.com/@d3/zoom-to-bounding-box
        //- Pie chart: https://observablehq.com/@d3/pie-chart
        //- features geometries of all states https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json 
        //- topology: topojson.js: https://unpkg.com/topojson@3
        //- html: how to use d3 code: https://d3js.org/getting-started
        //- Combine Zoomed map with pie chart: ChatGPT
        //- Change Color Map: ChatGPT
        //- Tool: Visual Studio Code
        //- Data source: Obesity data from CDC 2019: https://www.cdc.gov/obesity/data/prevalence-maps.html

        //go live with ip: http://localhost:8080/Zoombounding.html
        //Pan and zoom, or click to zoom into a particular state using zoom.transform transitions.The bounding box is computed using path.bounds.
        import { stateAndObe } from './zoombounding.js';
        function Chart(us) {
            const width = 2000;
            const height = 2000;

            const zoom = d3.zoom()
                .scaleExtent([1, 30])//limit zoom scale
                .on("zoom", zoomed);

            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, height])
                .attr("width", width)
                .attr("height", height)
                .attr("style", "max-width: 100%; height: auto;")
                .on("click", reset);

            const path = d3.geoPath();

            const g = svg.append("g");
            const populationData = stateAndObe; //import from zoombounding.js. Color scale based on obesity data




            //change color scale based on population data ***testing purpose only: ChatGPT***
            const minValue = d3.min(Object.values(populationData));
            const maxValue = d3.max(Object.values(populationData));
            const colorScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range(["#FFFFFf", "#800026"]);
            console.log(populationData);
            const states = g.append("g")
                .attr("fill", "#444")//default color gray
                .attr("cursor", "pointer")
                .selectAll("path")
                .data(topojson.feature(us, us.objects.states).features)
                .join("path")
                .attr("fill", d => colorScale(populationData[d.properties.name] || 0)) //change color scale based on population data ***testing purpose only***
                .on("click", clicked)
                .attr("d", path);

            states.append("title")
                .text(d => d.properties.name);

            g.append("path")
                .attr("fill", "none")
                .attr("stroke", "white")
                .attr("stroke-linejoin", "round")
                .attr("d", path(topojson.mesh(us, us.objects.states, (a, b) => a !== b)));

            /*g.selectAll("text")
                .data(topojson.feature(us, us.objects.states).features)
                .join("text")
                .attr("x", d => d3.geoPath().centroid(d)[0]) 
                .attr("y", d => d3.geoPath().centroid(d)[1])
                .text(d => d.properties.name);*/

            // Adding simple legend for 0%, 50%, 100%
            const legend = svg.append("g")
                .attr("transform", `translate(${(width - 150) / 2}, 20)`); // Center at top

            const legendPoints = [
                { value: minValue, color: colorScale(minValue), label: "0%" },
                { value: (minValue + maxValue) / 2, color: colorScale((minValue + maxValue) / 2), label: "50%" },
                { value: maxValue, color: colorScale(maxValue), label: "100%" }
            ];

            // Draw legend squares and labels
            legendPoints.forEach((point, i) => {
                // Draw square
                legend.append("rect")
                    .attr("x", i * 50) // Space squares 50px apart
                    .attr("y", 0)
                    .attr("width", 30)
                    .attr("height", 30)
                    .style("fill", point.color);

                // Draw label
                legend.append("text")
                    .attr("x", i * 50 + 10)
                    .attr("y", 35)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .text(point.label);
            });

            // Add legend title
            legend.append("text")
                .attr("x", 75) // Center of 3 squares (3 * 50 / 2)
                .attr("y", -5)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Obesity Rate (%)");

            svg.call(zoom);

            function reset() {
                //states.transition().style("fill", null);
                states.transition().style("fill", d => colorScale(populationData[d.properties.name] || 0));
                svg.transition().duration(750).call(
                    zoom.transform,
                    d3.zoomIdentity,
                    d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
                );
                g.selectAll(".pie-chart").remove(); // Remove pie chart when resetting the zoom
            }

            async function clicked(event, d) {
                g.selectAll(".pie-chart").remove();
                const [[x0, y0], [x1, y1]] = path.bounds(d);
                event.stopPropagation();
                states.transition().style("fill", d => colorScale(populationData[d.properties.name] || 0));
                // Highlight selected state by changing another states color to Gray
                //d3.select(this).transition().style("fill", "white");
                states.filter(state => state !== d).transition().style("fill", "#444");
                svg.transition().duration(750).call(
                    zoom.transform,
                    d3.zoomIdentity
                        .translate(width / 2, height / 2)
                        .scale(Math.min(15, 2.5 / Math.max((x1 - x0) / width, (y1 - y0) / height)))
                        .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
                    d3.pointer(event, svg.node())
                );
                // Start Draw Pie Chart when click on a state
                const stateName = d.properties.name;
                let data = {};
                if (choice === "race") {
                    data = await getRaceData(stateName);
                } else if (choice === "income") {
                    data = await getIncomeData(stateName);
                } else if (choice == "age") {
                    data = await getAgeData(stateName);
                }

                if (!data || !data.length) {
                    console.error("Check data in piechart.js");
                    return;
                }
                // Set up pie chart dimensions
                const stateWidth = x1 - x0; // width bounding box
                const stateHeight = y1 - y0; // height bounding box
                const minRadius = 50; // min radius
                const maxRadius = Math.min(stateWidth, stateHeight) * 0.3; // max radius is 30% of smaller dimension of bounding box
                const radius = Math.min(maxRadius, minRadius); // choose smaller one, ensure pie chart fits well within bounding box
                const pieWidth = 500;
                const pieHeight = Math.min(pieWidth, 500);

                // Create the color scale.
                const color = d3.scaleOrdinal()
                    .domain(data.map(d => d.name))
                    .range(d3.quantize(t => d3.interpolateSpectral(t * 0.8 + 0.1), data.length).reverse());

                // Create the pie layout and arc generator.
                const pie = d3.pie()
                    .sort(null)
                    .value(d => d.value);

                const arc = d3.arc()
                    .innerRadius(0)
                    .outerRadius(Math.min(pieWidth, pieHeight) / 2 - 1);

                const labelRadius = arc.outerRadius()() * 0.8;

                // A separate arc generator for labels.
                const arcLabel = d3.arc()
                    .innerRadius(labelRadius)
                    .outerRadius(labelRadius);

                const arcs = pie(data);

                // Create the SVG container.
                const pieSvg = d3.create("svg")
                    .attr("width", pieWidth)
                    .attr("height", pieHeight)
                    .attr("viewBox", [-pieWidth / 2, -pieHeight / 2, pieWidth, pieHeight])
                    .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");

                // Add a sector path for each value.
                pieSvg.append("g")
                    .attr("stroke", "white")
                    .selectAll()
                    .data(arcs)
                    .join("path")
                    .attr("fill", d => color(d.data.name))
                    .attr("d", arc)
                    .append("title")
                    .text(d => `${d.data.name}: ${d.data.value.toLocaleString("en-US")}`);

                // Create a new arc generator to place a label close to the edge.
                pieSvg.append("g")
                    .attr("text-anchor", "middle")
                    .selectAll()
                    .data(arcs)
                    .join("text")
                    .attr("transform", d => `translate(${arcLabel.centroid(d)})`)
                    .call(text => text.append("tspan")
                        .attr("y", "-0.4em")
                        .attr("font-weight", "bold")
                        .text(d => d.data.name))
                    .call(text => text.filter(d => (d.endAngle - d.startAngle) > 0.25).append("tspan")
                        .attr("x", 0)
                        .attr("y", "0.7em")
                        .attr("fill-opacity", 0.7)
                        .text(d => d.data.value.toLocaleString("en-US")));

                const [cx, cy] = path.centroid(d);
                // Đảm bảo pie chart không vượt ra ngoài bounding box
                const offsetX = (stateWidth - pieWidth * (radius / (pieWidth / 2))) / 2; // Điều chỉnh ngang
                const offsetY = (stateHeight - pieHeight * (radius / (pieWidth / 2))) / 2; // Điều chỉnh dọc
                g.append(() => pieSvg.node())
                    .attr("class", "pie-chart")
                    .attr("transform", `translate(${cx - offsetX}, ${cy - offsetY}) scale(${radius / (pieWidth / 2)})`);
            }

            function zoomed(event) {
                const { transform } = event;
                g.attr("transform", transform);
                g.attr("stroke-width", 1 / transform.k);
            }
            return svg.node();

        }

        //Use local topojson file states-albers-10m.json
        d3.json("states-albers-10m.json")
            .then(us => {
                console.log("TopoJSON loaded:", us); //check if JSON data is loaded
                const chart = Chart(us);
                document.getElementById("chart").appendChild(chart);
            })
            .catch(err => console.error("fail to load topojson:", err));

    </script>
</body>

</html>