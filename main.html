<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>D3 Map Example</title>
  </head>

  <body>
    <div style="margin: 10px">
      <label for="dataChoice">Show data by: </label>
      <select id="dataChoice">
        <option value="race">Race</option>
        <option value="income">Income</option>
        <option value="age">Age</option>
      </select>
    </div>
    <div id="chart"></div>

    <div id="chart"></div>
    <script src="/library/d3.v7.min.js"></script>
    <script src="/library/topojson.js"></script>
    <script src="/piechart.js"></script>
    <script src="/scatterplot.js"></script>
    <script type="module">
      let choice = "race"; // default
      document
        .getElementById("dataChoice")
        .addEventListener("change", function (e) {
          choice = e.target.value;
        });
      //References:
      //- Use Zoom to bounding box: https://observablehq.com/@d3/zoom-to-bounding-box
      //- Pie chart: https://observablehq.com/@d3/pie-chart
      //- features geometries of all states https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json
      //- topology: topojson.js: https://unpkg.com/topojson@3
      //- html: how to use d3 code: https://d3js.org/getting-started
      //- Combine Zoomed map with pie chart: ChatGPT
      //- Change Color Map: ChatGPT
      //- Tool: Visual Studio Code
      //- Data source: Obesity data from CDC 2019: https://www.cdc.gov/obesity/data/prevalence-maps.html

      //go live with ip: http://localhost:8080/Zoombounding.html
      //Pan and zoom, or click to zoom into a particular state using zoom.transform transitions.The bounding box is computed using path.bounds.
      import { stateAndObe } from "./zoombounding.js";
      function clearChart() {
        const chartDiv = document.getElementById("chart");
        while (chartDiv.firstChild) {
          chartDiv.removeChild(chartDiv.firstChild);
        }
      }
      async function updateChart() {
        clearChart();
        if (choice === "race" || choice == "age") {
          function Chart(us) {
            const width = 2000;
            const height = 2000;

            const zoom = d3
              .zoom()
              .scaleExtent([1, 100]) //limit zoom scale
              .on("zoom", zoomed);

            const svg = d3
              .create("svg")
              .attr("viewBox", [0, 0, width, height])
              .attr("width", width)
              .attr("height", height)
              .attr("style", "max-width: 100%; height: auto;")
              .on("click", reset);

            const path = d3.geoPath();

            const g = svg.append("g");
            const populationData = stateAndObe; //import from zoombounding.js. Color scale based on obesity data

            //change color scale based on population data ***testing purpose only: ChatGPT***
            const minValue = d3.min(Object.values(populationData));
            const maxValue = d3.max(Object.values(populationData));
            const colorScale = d3
              .scaleLinear()
              .domain([minValue, maxValue])
              .range(["#FFFFFf", "#800026"]);
            console.log(populationData);
            const states = g
              .append("g")
              .attr("fill", "#444") //default color gray
              .attr("cursor", "pointer")
              .selectAll("path")
              .data(topojson.feature(us, us.objects.states).features)
              .join("path")
              .attr("fill", (d) =>
                colorScale(populationData[d.properties.name] || 0)
              ) //change color scale based on population data ***testing purpose only***
              .on("click", clicked)
              .attr("d", path);

            states.append("title").text((d) => d.properties.name);

            g.append("path")
              .attr("fill", "none")
              .attr("stroke", "white")
              .attr("stroke-linejoin", "round")
              .attr(
                "d",
                path(topojson.mesh(us, us.objects.states, (a, b) => a !== b))
              );

            /*g.selectAll("text")
                .data(topojson.feature(us, us.objects.states).features)
                .join("text")
                .attr("x", d => d3.geoPath().centroid(d)[0]) 
                .attr("y", d => d3.geoPath().centroid(d)[1])
                .text(d => d.properties.name);*/

            /**** Adding simple legend for 0%, 50%, 100% ****/
            const legend = svg
              .append("g")
              .attr("transform", `translate(${(width - 150) / 2}, 20)`); // Center at top

            const legendPoints = [
              { value: minValue, color: colorScale(minValue), label: "0%" },
              {
                value: (minValue + maxValue) / 2,
                color: colorScale((minValue + maxValue) / 2),
                label: "50%",
              },
              { value: maxValue, color: colorScale(maxValue), label: "100%" },
            ];

            // Draw legend squares and labels
            legendPoints.forEach((point, i) => {
              // Draw square
              legend
                .append("rect")
                .attr("x", i * 50) // Space squares 50px apart
                .attr("y", 0)
                .attr("width", 30)
                .attr("height", 30)
                .style("fill", point.color);

              // Draw label
              legend
                .append("text")
                .attr("x", i * 50 + 10)
                .attr("y", 35)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text(point.label);
            });

            // Add legend title
            legend
              .append("text")
              .attr("x", 75) // Center of 3 squares (3 * 50 / 2)
              .attr("y", -5)
              .attr("text-anchor", "middle")
              .style("font-size", "14px")
              .text("Obesity Rate (%)");

            svg.call(zoom);

            function reset() {
              //states.transition().style("fill", null);
              states
                .transition()
                .style("fill", (d) =>
                  colorScale(populationData[d.properties.name] || 0)
                );
              svg
                .transition()
                .duration(750)
                .call(
                  zoom.transform,
                  d3.zoomIdentity,
                  d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
                );
              g.selectAll(".pie-chart").remove(); // Remove pie chart when resetting the zoom
            }

            async function clicked(event, d) {
              g.selectAll(".pie-chart").remove();
              const [[x0, y0], [x1, y1]] = path.bounds(d);
              event.stopPropagation();
              states
                .transition()
                .style("fill", (d) =>
                  colorScale(populationData[d.properties.name] || 0)
                );
              // Highlight selected state by changing another states color to Gray
              //d3.select(this).transition().style("fill", "white");
              states
                .filter((state) => state !== d)
                .transition()
                .style("fill", "#444");
              svg
                .transition()
                .duration(750)
                .call(
                  zoom.transform,
                  d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(
                      Math.min(
                        15,
                        2.5 / Math.max((x1 - x0) / width, (y1 - y0) / height)
                      )
                    )
                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
                  d3.pointer(event, svg.node())
                );
              /**** Start Draw Pie Chart when click on a state ****/
              const stateName = d.properties.name;
              let data = {};
              if (choice === "race") {
                data = await getRaceData(stateName);
              } else if (choice === "income") {
                data = await getIncomeData(stateName);
              } else if (choice == "age") {
                data = await getAgeData(stateName);
              }

              if (!data || !data.length) {
                console.error("Check data in piechart.js");
                return;
              }
              /**** Set up pie chart dimensions ****/
              const stateWidth = x1 - x0; // width bounding box
              const stateHeight = y1 - y0; // height bounding box
              const minRadius = 70; // min radius
              const maxRadius = Math.min(stateWidth, stateHeight) * 0.3; // max radius is 30% of smaller dimension of bounding box
              const radius = Math.min(maxRadius, minRadius); // choose smaller one, ensure pie chart fits well within bounding box
              const pieWidth = 500;
              const pieHeight = Math.min(pieWidth, 500);

              // Create the color scale.
              const color = d3
                .scaleOrdinal()
                .domain(data.map((d) => d.name))
                .range(
                  d3
                    .quantize(
                      (t) => d3.interpolateSpectral(t * 0.8 + 0.1),
                      data.length
                    )
                    .reverse()
                );

              // Create the pie layout and arc generator.
              const pie = d3
                .pie()
                .sort(null)
                .value((d) => d.value);

              const arc = d3
                .arc()
                .innerRadius(0)
                .outerRadius(Math.min(pieWidth, pieHeight) / 2 - 1);

              const labelRadius = arc.outerRadius()() * 0.8;

              // A separate arc generator for labels.
              const arcLabel = d3
                .arc()
                .innerRadius(labelRadius)
                .outerRadius(labelRadius);

              const arcs = pie(data);

              // Create the SVG container.
              const pieSvg = d3
                .create("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .attr("viewBox", [
                  -pieWidth / 2,
                  -pieHeight / 2,
                  pieWidth,
                  pieHeight,
                ])
                .attr(
                  "style",
                  "max-width: 100%; height: auto; font: 10px sans-serif;"
                );

              // Add a sector path for each value.
              pieSvg
                .append("g")
                .attr("stroke", "white")
                .selectAll()
                .data(arcs)
                .join("path")
                .attr("fill", (d) => color(d.data.name))
                .attr("d", arc)
                .append("title")
                .text(
                  (d) =>
                    `${d.data.name}: ${d.data.value.toLocaleString("en-US")}`
                );

              // Create a new arc generator to place a label close to the edge.
              pieSvg
                .append("g")
                .attr("text-anchor", "middle")
                .selectAll()
                .data(arcs)
                .join("text")
                .attr("transform", (d) => `translate(${arcLabel.centroid(d)})`)
                .call((text) =>
                  text
                    .append("tspan")
                    .attr("y", "-0.4em")
                    .attr("font-weight", "bold")
                    .text((d) => d.data.name)
                )
                .call((text) =>
                  text
                    .filter((d) => d.endAngle - d.startAngle > 0.25)
                    .append("tspan")
                    .attr("x", 0)
                    .attr("y", "0.7em")
                    .attr("fill-opacity", 0.7)
                    .text((d) => d.data.value.toLocaleString("en-US"))
                );

              const [cx, cy] = path.centroid(d);
              /**** Compute offset to center the pie chart in the state's bounding box ****/
              const offsetX =
                (stateWidth - pieWidth * (radius / (pieWidth / 2))) / 2; //Vertical offset
              const offsetY =
                (stateHeight - pieHeight * (radius / (pieWidth / 2))) / 2; //Horizontal offset
              g.append(() => pieSvg.node())
                .attr("class", "pie-chart")
                .attr(
                  "transform",
                  `translate(${cx - offsetX}, ${cy - offsetY}) scale(${
                    radius / (pieWidth / 2)
                  })`
                );
            }

            function zoomed(event) {
              const { transform } = event;
              g.attr("transform", transform);
              g.attr("stroke-width", 1 / transform.k);
            }
            return svg.node();
          }

          //Use local topojson file states-albers-10m.json
          d3.json("states-albers-10m.json")
            .then((us) => {
              console.log("TopoJSON loaded:", us); //check if JSON data is loaded
              const chart = Chart(us);
              document.getElementById("chart").appendChild(chart);
            })
            .catch((err) => console.error("fail to load topojson:", err));
        } else if (choice === "income") {
          async function createScatterPlot() {
            let data = await getScatterData();
            if (!data || !data.length) {
              console.error("Check data in scatterplot.js");
              return;
            }
            const width = 500;
            const height = 250;
            const marginTop = 10;
            const marginRight = 20;
            const marginBottom = 20;
            const marginLeft = 30;

            // Create the horizontal (x) scale for money income
            const x = d3
              .scaleLinear()
              .domain([0, d3.max(data, (d) => d["value"])])
              .nice()
              .range([marginLeft, width - marginRight])
              .unknown(marginLeft);

            // Create the vertical (y) scale for obesity
            const y = d3
              .scaleLinear()
              .domain([0, d3.max(data, (d) => d["obesity"])])
              .nice()
              .range([height - marginBottom, marginTop])
              .unknown(height - marginBottom);

            // Define color scale for different income types
            const color = d3
              .scaleOrdinal()
              .domain(["Households", "Families", "Married-couple", "Nonfamily"])
              .range(["steelblue", "orange", "green", "purple"]);

            // Create the SVG container
            const svg = d3
              .create("svg")
              .attr("viewBox", [0, 0, width, height])
              .property("value", []);

            // Append the x-axis (money income)
            svg
              .append("g")
              .attr("transform", `translate(0,${height - marginBottom})`)
              .call(d3.axisBottom(x))
              .call((g) => g.select(".domain").remove())
              .call((g) =>
                g
                  .append("text")
                  .attr("x", width - marginRight)
                  .attr("y", -4)
                  .attr("fill", "#000")
                  .attr("font-weight", "bold")
                  .attr("text-anchor", "end")
                  .text("Money Income (dollars)")
              );

            // Append the y-axis (obesity)
            svg
              .append("g")
              .attr("transform", `translate(${marginLeft},0)`)
              .call(d3.axisLeft(y))
              .call((g) => g.select(".domain").remove())
              .call((g) =>
                g
                  .select(".tick:last-of-type text")
                  .clone()
                  .attr("x", 4)
                  .attr("text-anchor", "start")
                  .attr("font-weight", "bold")
                  .text("Obesity (%)")
              );

            // Append the dots with different colors and symbol

            const dot = svg
              .append("g")
              .attr("fill", "none")
              .attr("stroke", "steelblue")
              .attr("stroke-width", 1.5)
              .selectAll("circle")
              .data(data)
              .join("circle")
              .attr(
                "transform",
                (d) => `translate(${x(d["value"])},${y(d["obesity"])})`
              )
              .attr("fill", (d) => color(d["incomeType"]))
              .attr("r", 3);

            // Add legend for income types
            const legend = svg
              .append("g")
              .attr("transform", `translate(${width - 150}, ${marginTop})`);

            const incomeTypes = [
              "Households",
              "Families",
              "Married-couple",
              "Nonfamily",
            ];
            incomeTypes.forEach((type, i) => {
              const legendRow = legend
                .append("g")
                .attr("transform", `translate(0, ${i * 20})`);

              legendRow
                .append("circle")
                .attr("cx", 10)
                .attr("cy", 5)
                .attr("r", 5)
                .attr("fill", color(type))
                .attr("stroke", "none");

              legendRow
                .append("text")
                .attr("x", 20)
                .attr("y", 5)
                .attr("font-size", "12px")
                .text(type);
            });

            return svg.node(); // Return the SVG node
          }

          createScatterPlot().then((node) => {
            if (node) {
              document.getElementById("chart").appendChild(node);
            }
          });
        }
      }
    updateChart();
      document
        .getElementById("dataChoice")
        .addEventListener("change", function (e) {
          choice = e.target.value;
          updateChart(); // Gọi lại hàm updateChart khi choice thay đổi
        });
    </script>
  </body>
</html>
